package com.zhaojb.learn.inherit;

public class Reflect {
	//反射库提供了一个非常丰富且精心设计的工具集
	//以便编写能够动态操纵Java代码的程序
	//这项功能被大量地应用于JavaBeans中
	//使用反射，Java可以支持VB用户习惯使用的工具，特别是在设计或运行中添加新类时，能够快速
	//地应用开发工具动态地查询新添加的类的能力
	//能够分析类能力的程序称为反射
	//反射机制的功能极其强大，在下面可以看到，反射机制可以用来
	//在运行中分析类的能力
	//在运行中查看对象，例如，编写一个toString方法供所有类使用
	//实现通用的数组操作代码
	//利用Method对象，这个对象很像c++中的函数指针
	
	/******************************************/
	//Class类
	//在程序运行期间，java运行时系统始终为所有的对象维护一个称为运行时的类型标识
	//这个信息跟踪着每个对象所属的类，虚拟机运用运行时类型信息选择相应的方法执行
	//可以通过Class来保存这些信息
	//Employee e;
	//Class cl = e.getClass();
	//可以通过上述方法来获取一个Class类型的实例
	//e.getClass().getName()是用来获取类的名字
	//还可以调用Class.forName(str)来获取相应的Class对象
	//这个方法仅仅在于这个是类名或接口名时候才能够执行
	//无论何时使用这个方法，都应该提供一个异常处理器
	//获取Class类对象的第三种方法非常简单，
	//Class cl1 = Date.class;
	//上述得到是一个Class
	//可以使用==运算符实现两个类对象比较的操作
	//if(e.getClass()==Employee.class)
	//可以使用e.getClass.newIntance();来快速创建一个类的实例
	//会调用默认的构造器，如果这个类没有默认的构造器，就会抛出一个异常
	//String s = "java.util.Date";
	//Object m = Class.forName(s).newInstance();
	/**********************/
	//异常分为两个种类，未检查异常和已检查异常
	//对于已检查异常，编译器将会检查是否提供了处理器
	/*************************/
	//利用反射分析类的能力
	/********************************/
	//在运行时使用反射分析对象
	//使用反射编写泛型数组代码
	//先获取a的Class对象
	//分析a的Class对象是不是数组
	//获取a的Class对象中的类型(利用c1.getComponentType());
	//利用Array.getLength()获取数组的长度
	//利用Array.newInstance获取一个新的数组对象
	//利用System.arraycopy()获取新的copy对象
	//返回这个obj
	/*******************************/
	//利用反射调用任意方法
	//Method m = a.class.getMethod("getName");
	//Method m = a.class.getMethod("getName",double.class);
	//使用反射获得方法指针的代码要比仅仅直接地调用方法明显慢一些
	//最好使用接口和内部类
	/*****************************/
	//将公共操作和域放在超类
	//不要使用受保护的域
	//使用继承实现"is-a"关系
	//除非所有继承的方法都是有意义的，否则不要使用继承
	//在覆盖方法时，不要改变预期的行为
	
}
