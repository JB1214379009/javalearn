package com.zhaojb.learn.inherit;

public class Manager extends Employee{
	//java中，所有的继承都是公有继承
	//父类与子类
	//在设计类的时候，应当把通用的方法放在超类中，
	//而将通用的方法放在超类中
	//超类中的有些方法对子类并不一定适用，需要覆盖
	//不能直接访问私有域
	//如果想要调用超类的方法，则可以采用super.method()来使用
	//不能删除继承的任何域和方法
	//子类默认调用父类的默认构造器
	//显示调用的话采用super
	private double bonus;

	public void setBonus(double bonus) {
		this.bonus = bonus;
	}
	
	//一个对象变量可以指示多种实际类型的现象称为多态
	//在运行时能够自动选择调用哪个方法的现象称为动态绑定
	//final可以阻止继承
	//在强制转换之前，先使用instance of来检测是否可以转换
	//在将超类转换成子类之前，先用instance of进行检查
	//形如 x instance of C不会产生异常，只是返回false
	//只有在使用Manager中特有的方法才需要进行类型转换
	//抽象类不能被实例化
	//可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象
	//受保护的方法protected更有实际意义
	//protected对本包和所有子类可见
	//如果没有明确指出超类，object就被认为是这个类的超类
	//只有基本类型不是对象
	//equals方法用于检测一个对象是否等于另外一个对象
	//在ob类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同的引用，那么他们
	//一定是相等的
	//状态相等比较合情合理一点
	/*******************************/
	//1.显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量
	//2.检测this与otherObject是否引用同一个对象
	//3.if（this==otherobject）return true；
	//4.检测是否属于同一个类，使用getClass检测，只有相同才有可能相等
	//采用instance of来检测，只有可以才有可能相等
	//强转
	//比较大小
	//子类重新定义时候，记得先调用super。equals
	/***************************************/
	//hashCode方法
	//散列码是由对象导出的一个整型值，散列码没有规律
	//如果x和y是两个不同的对象，基本上不会相同
	//hashCode方法应该返回一个整型数值，也可以是负数，并合理地组合实例域的散列码，以便能够
	//让各个不同的对象产生的散列码更加均匀
	//最好使用Objects。hashCode来做
	//Objects。hash可以组合这些散列值
	//如果x跟y相等，则hash必然相等
	//基本类型的域要用类装起来做hashcode
	/***********************/
	//toString字符串最好使用getClass().getName();
	//只要对象与一个字符串通过操作符+链接起来，java编译
	//就会自动调用toString方法，以便获得这个对象的字符串描述
	//在调用x。toString的地方可以采用""+x替代，会自动调用
	//强烈建议为自己定义的每一个类都增加一个toString方法
	//当确定无需再添加时候，再调用trimToSize
	//一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块
	//arraylist的add方法是为数组添加新元素
	//set方法是替换数组中原本已经存在的元素内容
	//利用arraylist.toArray可以转成数组
	//采用for each来遍历数组
	/*********************************/
	//这些类称为包装器
	//自动装箱自动拆箱
	//两个包装器对象比较要调用equals
	//参数可变的方法
	//例如system.out.printf
	//采用Object...进行自动装箱
	//可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何
	//已经存在的代码
}
