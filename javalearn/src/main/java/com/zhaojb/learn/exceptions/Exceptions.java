package com.zhaojb.learn.exceptions;

import com.sun.org.apache.bcel.internal.generic.NEW;
import com.zhaojb.learn.inherit.Employee;

import sun.print.resources.serviceui;

public class Exceptions {
	//如果由于出现错误而使得某些操作没有完成，程序应该
	//允许用户保存所有操作的结果，并以适当的方式终止程序
	//用户输入错误、设备错误、物理限制、代码错误
	//一种表示错误状态状况的常用返回值是null引用
	//异常分类
	//在Java程序设计语言中，异常对象都是派生于Thorwable类的一个实例
	//如果Java中内置的异常类不能够满足需求，用户可以创建自己的异常类
	//需要注意的是，所有的异常都是由Throwable继承而来的，但是在下一层立即分解
	//为两个分支 Error和Exception
	//Error类层次结构描述了Java运行时系统的内部错误和
	//资源耗尽错误
	//应用程序不应该抛出这个类型的对象
	//Runtimeexception是程序错误导致的异常，
	//程序本身没有问题，但由于像I/O错误这种问题导致的异常属于其他异常
	//如果出现runtime的话，那一定是你的问题
	//未检查异常 派生于error跟runtimeexception的所有异常
	//所有其他的异常称为已检查异常
	//编译器将核查是否为所有的已检查异常提供了异常处理器
	//对于那些可能被他人使用的java方法，应该根据异常规范，
	//在方法的首部声明这个方法可能抛出的异常
	//抛出多个已检查异常，那就必须在方法的首部列出所有的异常类，中间用逗号隔开
	//不需要声明java的内部错误，即从error继承的错误，
	//任何程序代码都具有抛出那些异常的潜能，而我们没有控制能力
	//同样也不需要声明从RuntimeException继承的那些未检查异常
	//总之，一个方法必须声明所有可能抛出的已检查异常，而
	//未检查异常要么不可控制
	//要么就应该避免发生
	//如果方法没有声明所有可能发生的已检查异常，编译器就会给出一个错误信息
	//处了声明异常之外，还可以捕获异常，这样会使得异常不被抛到方法之外
	//子类覆盖了超类的方法，子类必须抛出更加特定的异常
	//如果超类方法不抛出任何已检查异常，子类也不能抛出任何已检查异常
	//如果类中的一个方法声明将会抛出一个异常，
	//而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常，
	//或者这个任意一个子类的异常
	//一旦方法抛出了异常，这个方法就不可能返回到调用者
	//不必为返回的默认值或错误代码担忧	
	//创建异常类，只需要定义一个派生于exception或者派生于exception子类的类
	//定义类应该包含两个构造器，一个是默认的构造器，另外一个是带有详细信息的构造器，string入参
	//然后就可以抛出自己定义的异常类型了
	/*******************************************/
	//捕获异常
	//要想捕获一个异常，必须设置try/catch语句块
	//如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么
	//程序将跳过try语句块的其余代码
	//程序将执行catch子句中的处理器代码
	//最好的选择是什么也不做，而是将异常传递给调用者
	//捕获多个异常
	//异常对象本身可能包含与异常本身有关的信息
	//可以试着调用e.getMessage();
	//或者e.getClass.getName();
	//采用catch(FileNotFoundException | UnknownHostException e)
	//可以合并catch子句(只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性)
	//再次抛出异常与异常链
	//在catch中可以重新throw一个新的异常
	//推荐采用throwable se = new ServletException("xxxx");
	//se.initCause(e);
	//throw se;
	//强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常
	//finally子句无论怎样也会最终实行
	//分析堆栈跟踪元素
	/*********************************/
	//只在异常情况使用异常，捕获异常需要花费大量时间
	//不要过分细化异常
	//不要只抛出runtimeexcption异常，应该寻找更加适当的子类或创建自己的异常类
	//不要只捕获throwable异常
	//不要压制异常
	//在检测错误时，“苛刻”要比放任更加好
	//不要羞于传递异常
	//断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测会被自动地移走
	//java引入了assert关键字
	//这个关键字有两种形式
	//assert 条件
	//assert 条件:表达式
	//这两种形式都会对条件进行检测，如果结果为false，则抛出一个assertionerror异常
	//在第二种形式中，表达式会被传入assertionerror的构造器，并转换为一个消息字符串
	//表达式部分的唯一目的是产生一个消息字符串
	//不可能在以后得到她
	//默认情况下断言被禁用
	//启动或禁用断言不需要重新编译程序
	//是类加载器的功能
	//断言失败是致命的、不可恢复的错误
	//断言检查只用于开发和检测阶段
	private Pair<String> pair ;
}

class Pair<T>{
	private T first;
	private T second;
}

class ArrayAlg{
	public static <T extends Employee & Comparable> T getMiddle(){
		return null;
	}
}

//虚拟机没有泛型对象--所有对象都属于普通类
//无论何时定义一个泛型类型，都自动提供了一个相应的原始类型
//原始类型的名字就是山区类型参数后的泛型类型名
//擦除类型变量，并替换为限定类型（无限定的变量用object）
//例如上述，因为T是没有限定的变量，所以直接用object替换
//原始类型用第一个限定的类型变量替换，如果没有给定限定就用object替换
//当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换
//方法的擦除带来了两个复杂问题
//java泛型转换的事实
//虚拟机中没有泛型，只有普通的类和方法
//所有的类型参数都用它们的限定类型替换
//桥方法被合成来保持多态
//为保持类型安全性，必要时插入强制类型转换
//java泛型时候的约束
//不能用基本类型实例化类型参数
//运行时类型查询只适用于原始类型
//不能创建参数化类型的数组
//向可变参数个数方法传递一个泛型类型的实例会得到一个varargs警告
//不能实例化类型变量
//泛型类的静态上下文中类型变量无效
//不能抛出或者捕获泛型类的实例
