package com.zhaojb.learn.interfaces;

public class InterfacesLearn {
	//接口技术主要用来描述类具有什么功能，而并不是给出每个功能的具体实现
	//一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象
	//对象的克隆是指创建一个新对象，且新对象的状态与原始对象的状态相同，
	//当对克隆的新对象进行修改时，不会影响原始对象的状态
	//内部类定义在另外一个类的内部，其中的方法可以访问他们的外部类的域
	//内部类技术定义在另外一个类的内部，其中的方法可以访问包含他们的外部类的域
	//这是一项比较复杂的技术
	//内部类技术主要用于设计具有相互协作管理的类的集合
	//接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义
	//如果累遵从某个特定接口，那么就履行这项服务
	//接口中的所有方法自动地属于public，因此，在接口中声明方法时，不必提供关键字public
	//尽管不能构造接口的对象，却能声明接口的变量
	//接口变量必须引用实现了接口的类型
	//虽然接口不能包含实例域或静态方法，却可以包含常量
	//域被自动设为public static final
	//同时使用两个以上的接口时候，采用Cloneable,Comparable
	//当拷贝一个变量时，原始变量与拷贝变量引用同一个对象
	//改变一个变量所引用的对象将会对另一个变量产生影响
	//默认的克隆操作是浅拷贝
	//它并没有克隆包含在对象中的内部对象
	//自定义的类使用(A)super.clone();
	//系统存在的变量使用a.clone();
	//回调是一种常见的程序设计模式，在这种模式中，可以指出某种特定事件发生时应该采取的动作
	//内部类是定义在另一个类中的类
	//内部类可以访问该类定义所在的作用域中的数据，包括私有数据
	//内部类可以对同一个包中的其他类隐藏起来
	//当想要定义一个回调函数且不想编写大量代码时候，使用匿名内部类比较便捷
	//如下就是一个内部类
	public class InnerClass{
		
	}
	//一个方法可以引用调用这个方法的对象数据域
	//内部类既可以访问自身的数据域，也可以访问创建它的外围对象的数据域
	//内部类的对象总有一个隐式引用，它指向了创建它的外部类对象
	//这个引用在内部类的定义中是不可见的
	//外围类的引用在构造器中设置，编译器修改了所有的内部类的构造器，
	//添加了一个外围类引用的参数
	//只有内部类可以是私有类，而常规类只可以具有保可见性
	//内部类的特殊语法规则
	//事实上，使用外围类引用的正规语法还要复杂一些
	//要采用OuterClass.this.xxxx的方式来引用
	//需要注意，在外围类的作用域之外，可以这样引用内部类
	//OuterClass.InnerClass
	//内部类只能引用fial型变量
	//匿名内部类
	//双括号初始化
	//静态内部类，有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，
	//并不需要内部类引用外围类对象，为此，可以将内部类声明为static，以便取消产生的引用
	//只有内部类可以声明为static，静态内部类的对象除了没有对生成它的外围类对象的引用
	//特权外，与其他所有内部类完全一样
	//在内部类不需要访问外围类对象的时候，应该使用静态内部类
	//有些程序员用嵌套类表示静态内部类
	/*************************************/
	//代理，利用代理可以在运行时创建一个实现了一组给定接口的新类，这种
	//功能只有编译时无法确定需要实现哪个接口时才有必要使用
	//代理可以在运行时创建全新的类
	//代理类是在程序运行过程中创建的
	//然而，一旦被创建，就变成了常规类，与虚拟机中的任何其他类没有什么区别
	//所有的代理类都扩展于Proxy类，一个代理类只有一个实例域---调用处理器
	//它定义在Proxy的超类中
}
class test{}
